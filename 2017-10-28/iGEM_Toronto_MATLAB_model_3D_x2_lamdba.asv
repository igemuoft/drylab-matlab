%% iGEM Toronto 2017 Dry Lab MATLAB model %%
% Further documentation goes here.
%
%
%

%% Parameter Definitions %%
% In this section, the parameters for the model are listed and defined.
%
% start_time: starting time value of simulation. Default is 0
%
% end_time: ending time value of the simulation. Total duration of
% simulation is thus end_time - start_time
%
% precision: time taken for each step of the runge-kutta method. less time
% value = more accurate results
%
% light_period: period of time between each toggle of the light switch
% (total period of mu / 2)
%
% time: this is the time vector for the model. It simply deflined by the
%       linspace function. The linspace funcation has the parameters (X1, X2, N),
%       where X1 is start point, X2 is end point, and N is the number of steps
%       between them.

% modify these values as needed
start_time = 0;
end_time = 2;
precision = 0.1; % lower = more accurate
light_period = 2;

total_points = (end_time - start_time) / precision;
time = linspace(start_time, end_time, total_points);

% n: the exponent in the Michaelis Menten Equations
n = 1;

% alpha_2:
alpha_2 = 0.92356;

% K_1:
K_1 = 0.3;

% R_1:
R_1 = 1.7;

% mu: this is the light function, defined as a square wave oscillating
%     between values 0 (off) and 1 (on). The duty cycle can be altered by
%     including factors to adjust the 't' value.
%mu = @(t) (square(t, 50)+1)/2; % using square function (works)
mu = @(t) mod(ceil(t./light_period),2); % w/o square() - also works now

% psi_1: 
psi_1 = @(t) alpha_2/((K_1^n + R_1^n).^(1-mu(t)));

% gamma_2: 
gamma_2 = 1;

% alpha_theta:
alpha_theta = 1.6;

% gamma_theta:
gamma_theta = 1;

% k: 
k = alpha_theta/alpha_2;

% alpha_x:
alpha_x = 1.4;

% gamma_L:
gamma_L = 0.6;

%% Listing of the Differential Equations %%
% In this section, the differential equations of interest for the model are
%   listed, defined, and solved for. This model is currently solved using the
%   Runge-Kutta method, with the 'rk' function written by Peter Brinkmann. The
%   'rk2' function uses the same algorithm, but was slightly adapted to allow
%   for a third parameter to be included in the inline function.

% Equation 5 - dx2/dTau:
%   This is
dx2 = @(t, x2) psi_1(t) - gamma_2*x2;
solnX = rk(dx2, 1, time);

% Equation 6 - dTheta/dTau:
%   This is
dT = @(t, T) k.*psi_1(t) - gamma_theta*T;
solnT = rk(dT, 1, time);

% Equation 7 - dLambda/dTau:
%   This is
dL = @(t, L, x2) (alpha_x/(1 + x2^n)) - gamma_L*L;
solnL = rk2(dL, 0, solnX, time);

%% Finding steady-state solutions %%

% psi_1_on
psi_1_on = alpha_2;
% psi_1_off
psi_1_off = alpha_2/(K_1^n + R_1^n);

% solutions for on
x2_on = psi_1_on / gamma_2;
T_on = k .* psi_1_on / gamma_theta;
L_on = alpha_x / ((1+x2_on^n) * gamma_L);
disp(['light on',newline,'x2: ',num2str(x2_on),newline,'theta: ',num2str(T_on),newline,'lambda: ',num2str(L_on)])

% solutions for off
x2_off = psi_1_off / gamma_2;
T_off = k .* psi_1_off / gamma_theta;
L_off = alpha_x / ((1+x2_off^n) * gamma_L);
disp([newline,'light off',newline,'x2: ',num2str(x2_off),newline,'theta: ',num2str(T_off),newline,'lambda: ',num2str(L_off)])

%% Plotting of the Solutions %%

plot(time, solnX, time, solnT, time, solnL, time, mu(time));
title('Plot of Equations 5, 6, and 7, along with Light Values');
ylabel('Concentrations');
xlabel('time');
legend('x2', 'theta', 'lambda', 'light', 'Location', 'NE');
axis([-inf inf 0 1.8])

figure
%the 3D Plot for Tau
[K, gT] = meshgrid(0:0.5:10, 0:0.5:10);
Theta = parasweep_kG(K, gT, 1);

surf(K, gT, Theta)
xlabel('k')
ylabel('\gamma_\theta')
zlabel('\theta')
title('Output of \theta for parameters k and \gamma_\theta and light ON')

figure
%the 3D Plot for Tau

Theta_off = parasweep_kG(K, gT, 0);

surf(K, gT, Theta_off)
xlabel('k')
ylabel('\gamma_\theta')
zlabel('\theta')
title('Output of \theta for parameters k and \gamma_\theta and light OFF')


figure
%the 3D Plot for x_2
[g2, a2] = meshgrid(0:0.1:10, 0:0.1:10);
X2 = parasweep_G2_A2(g2, a2, 1);

surf(g2, a2, X2)
xlabel('\gamma_2')
ylabel('\alpha_2')
zlabel('x_2')
title('Output of x_2 for parameters \alpha_x and \alpha_2 and light ON')


figure
%the 3D Plot for x_2

X2_off = parasweep_G2_A2(g2, a2, 0);

surf(g2, a2, X2_off)
xlabel('\gamma_2')
ylabel('\alpha_2')
zlabel('x_2')
title('Output of x_2 for parameters \alpha_x and \alpha_2 and light OFF')

figure
%the 3D Plot for lambda
[ax, gL] = meshgrid(0:0.1:10, 0:0.1:10);
L_on = parasweep_ax_gL(ax, gL, X2(:,1), 1);

surf(ax, gL, L_on)
xlabel('\alpha_x')
ylabel('\gamma_\lambda')
zlabel('\lambda')
title('Output of \lambda for parameters \alpha_x and \gamma_\lambda and light ON')

figure
%the 3D Plot for lambda

L_off = parasweep_ax_gL(ax, gL, X2_off(:,1),0);

surf(ax, gL, L_off)
xlabel('\alpha_x')
ylabel('\gamma_\lambda')
zlabel('\lambda')
title('Output of \lambda for parameters \alpha_x and \gamma_\lambda and light OFF')
